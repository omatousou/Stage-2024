    e = 0.002;
    e3 = 0.005;
    t1 = deg2rad(theta1-calibration);
    neff = (neffLP+neffSP)/2;
    neff2 = (neff2LP+neff2SP)/2;
    nair = 1.000293;
    t2 = deg2rad(theta2-calibration2);
    i1 = asin(nair/neff*sin(t1));
    i2 = asin(nair/neff2*sin(t2));
    DE1 = e*sin(t1-i1)/cos(i1);
    DE2 = e*sin(t2-i2)/cos(i2);
    nlame3=2.13;
    theta3 = rad2deg(-(DE2+DE1)/(e3*(1-nair/nlame3)));
    mir = elliptec_driver([1,2,3],'COM8');
    p=set_position(mir,3,theta3+141.5);

% Initialisation des paramètres
calibration2temp = -40; % Définir la valeur de calibration2 temporaire
[~, ~, ~] = Anatole_spectro_mirrror(calibration2temp - 90, spectro, 2); % Pivot du deuxième miroir

% Définir la plage d'angles et initialiser les matrices de données
range = 0:10:360; % Plage d'angles à parcourir
DATA = zeros(length(range), 2000); % Matrice de données d'acquisition
SIG = DATA; % Matrice des signaux filtrés
Xtemp = zeros(length(range), 2); % Matrice temporaire des positions X
angletemp = zeros(size(range)); % Vecteur temporaire des angles

[~, ~, ~] = Anatole_spectro_mirrror(141.5, spectro, 3)
% Boucle sur la plage d'angles
for j = 1:length(range)
    i = range(j); % Angle courant
    [x, y, ~] = Anatole_spectro_mirrror(i, spectro, 1); 
    DATA(j, :) = y; % Stocker les données dans DATA

    % Tracer les données de spectroscopie pour l'angle courant
    plot(x, DATA(j, :)); hold on;

    % Appliquer un filtre médian pour lisser et normaliser les données
    sig = normalize(medfilt1(DATA(j, :), 3), 'range');
    SIG(j, :) = sig; % Stocker le signal normalisé dans SIG

    % Détecter les points où le signal dépasse un seuil (0.22)
    DERIV = sig > 0.22;
    Xfirst = find(DERIV, 1, 'first');
    Xlast = find(DERIV, 1, 'last');

    % Vérifier que les positions détectées sont valides
    if ~isempty(Xfirst) && ~isempty(Xlast) && (x(Xlast) - x(Xfirst)) > 5 && (x(Xlast) - x(Xfirst)) < 25
        % Stocker les positions valides dans Xtemp
        Xtemp(j, :) = [x(Xfirst), x(Xlast)];
        angletemp(j) = i; % Stocker l'angle correspondant
        fprintf("ADDED\n");
        disp([x(Xfirst), x(Xlast), DATA(j, Xfirst), DATA(j, Xlast)]);

        % Marquer les positions détectées sur le graphique
        scatter([x(Xfirst), x(Xlast)], [DATA(j, Xfirst), DATA(j, Xlast)]);
    end
end
hold off;

% Filtrer les positions valides stockées dans Xtemp
valid_idx = Xtemp(:, 1) ~= 0;
X = Xtemp(valid_idx, :);
angle = angletemp(valid_idx);

% Ajuster les courbes pour obtenir les paramètres de calibration
[x0LP, neffLP, phaseLP] = AnatoleCurveFit(angle, X(:, 1), max(X(:, 1)), angle(X(:, 1) == max(X(:, 1))));
[x0SP, neffSP, phaseSP] = AnatoleCurveFit(angle, X(:, 2), max(X(:, 2)), angle(X(:, 2) == max(X(:, 2))));

% Calculer la valeur de calibration
calibration = (mod(phaseLP, 180) + mod(phaseSP, 180)) / 2;

% Acquisition des données de spectroscopie pour la calibration
[x, y, ~] = Anatole_spectro_mirrror(calibration, spectro, 1);





% Définir la plage d'angles et initialiser les matrices de données
range = 0:10:360; % Plage d'angles à parcourir
DATA = zeros(length(range), 2000); % Matrice de données d'acquisition
SIG = DATA; % Matrice des signaux filtrés
Xtemp = zeros(length(range), 2); % Matrice temporaire des positions X
angletemp = zeros(size(range)); % Vecteur temporaire des angles

% Boucle sur la plage d'angles
for j = 1:length(range)
    i = range(j); % Angle courant
    
    [~, ~, ~] = Anatole_spectro_mirrror(141.5, spectro, 3)
    [x, y, ~] = Anatole_spectro_mirrror(i, spectro, 1); 
    DATA(j, :) = y; % Stocker les données dans DATA

    % Tracer les données de spectroscopie pour l'angle courant
    plot(x, DATA(j, :)); hold on;

    % Appliquer un filtre médian pour lisser et normaliser les données
    sig = normalize(medfilt1(DATA(j, :), 3), 'range');
    SIG(j, :) = sig; % Stocker le signal normalisé dans SIG

    % Détecter les points où le signal dépasse un seuil (0.22)
    DERIV = sig > 0.22;
    Xfirst = find(DERIV, 1, 'first');
    Xlast = find(DERIV, 1, 'last');

    % Vérifier que les positions détectées sont valides
    if ~isempty(Xfirst) && ~isempty(Xlast) && (x(Xlast) - x(Xfirst)) > 5 && (x(Xlast) - x(Xfirst)) < 25
        % Stocker les positions valides dans Xtemp
        Xtemp(j, :) = [x(Xfirst), x(Xlast)];
        angletemp(j) = i; % Stocker l'angle correspondant
        fprintf("ADDED\n");
        disp([x(Xfirst), x(Xlast), DATA(j, Xfirst), DATA(j, Xlast)]);

        % Marquer les positions détectées sur le graphique
        scatter([x(Xfirst), x(Xlast)], [DATA(j, Xfirst), DATA(j, Xlast)]);
    end
end
hold off;

% Filtrer les positions valides stockées dans Xtemp
valid_idx = Xtemp(:, 1) ~= 0;
X = Xtemp(valid_idx, :);
angle = angletemp(valid_idx);

% Ajuster les courbes pour obtenir les paramètres de calibration
[x0LP, neffLP, phaseLP] = AnatoleCurveFit(angle, X(:, 1), max(X(:, 1)), angle(X(:, 1) == max(X(:, 1))));
[x0SP, neffSP, phaseSP] = AnatoleCurveFit(angle, X(:, 2), max(X(:, 2)), angle(X(:, 2) == max(X(:, 2))));

% Calculer la valeur de calibration
calibration = (mod(phaseLP, 180) + mod(phaseSP, 180)) / 2;

% Acquisition des données de spectroscopie pour la calibration
[x, y, ~] = Anatole_spectro_mirrror(calibration, spectro, 1);
